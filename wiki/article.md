# 함수형 프로그래밍


이 자료는 "한국 플레이! 사용자 그룹"에서 네이버 D2 커뮤니티 지원으로 진행된 스터디의 결과물로 작성되었습니다. 해당 스터디에 대한 산출물은 [Github](https://github.com/kpug/fpis)에서 확인할 수 있습니다. 내용상 문의사항이나 오탈자 등은 이슈/PR로 제보해 주시면 적극 반영하겠습니다. 감사합니다.


## 1장 패러다임의 전환

함수형 프로그래밍을 알아보기 전에 왜 함수형 프로그래밍이 최근 자주 이야기되고 있는지 짚고 넘어가야 할 필요가 있을 것 같다. 이렇게 약을 팔아야 이 긴 글을 읽어주실 것이니까. 가볍게 읽을 수 있는 서문으로  준비했다. 자 이제 시작해보자.

### 1.1 프로그래밍 패러다임

패러다임의 사전적 의미를 살펴보면 다음과 같다. "어떤 한 시대 사람들의 견해나 사고를 근본적으로 규정하고 있는 테두리로서의 인식의 체계. 또는 사물에 대한 이론적인 틀이나 체계". 프로그래밍에도 이런 패러다임이 존재한다. 개발자들의 견해나 인식의 체계가 바로 프로그래밍의 패러다임이다. 달리 이야기해서 프로그래밍 패러다임은 기능에 따라 프로그래밍 언어를 분류하는 방법이라고 이야기 할 수 있다. 프로그래밍 패러다임은 크게 2가지로 분류가 되는데 명령형 패러다임(imperative paradigm)과 선언형 패러다임(declarative paradigm)이다.

명령형 패러다임은 때때로 절차적(Procedural)과 동의어로 사용되며, 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍들을 말한다. 잘 알려져 있는 C 언어, Java, 포트란, 알골, 파스칼, 에이다 까지가 이 패러다임을 따르고 있다.

선언형 패러다임은 연산을 설명하기 보다는 문제를 해결하는 방법을 제시하는 프로그래밍을 가리킨다. 이러한 패러다임에 속하는 것이 함수형 프로그래밍이며, 잘 알려져 있는 언어로 Scala, Groovy, 클로져, 하스켈 등을 들 수 있다.

코드로 살펴보면 두가지의 차이를 좀 더 명확하게 느낄 수 있다. 예제는 누구나 이해할 수 있는 수준인 1 ~ 10 사이의 정수를 더하는 프로그램을 자바 코드로 준비했다. 아래의 코드를 살펴보자.

##### 코드1.1 명령형의 자바 코드

````java
int sum = 0
for(int i = 1 ; i <= 10; i++ ) {
    sum = sum + i;
}
````

##### 코드2.1 선언형의 자바 코드

````java
int sum = IntStream.rangeClosed(1, 10).reduce(0, (a, b) -> a+b)
````


우선 코드1을 살펴보면 전형적인 명령형 프로그래밍으로 우선 sum 변수를 만들고(; 프로그래밍의 상태) 1 부터 10까지를 반복하면서 그 수를 sum에 반복적으로 더한다 (; 그 상태를 변경 ).

코드2에 대해서 살펴보자 IntStream은 자바8에서 추가 된 것으로 IntStream.rangeClosed(1, 10)코드 까지 실행되고 나면 1 ~ 10까지의 배열이 생기게 되고(; 실제로 배열이 생성되는 건 아니지만 지금은 그렇게 생각하자.), 이후에 reduce는 초깃 값은 0이고 각 원소에 대해서 두 개를 더하라고 지시(; 문제 해결 방법을 제시)하게 된다.

자 이제 명령형 프로그래밍과 선언형 프로그래밍에 차이를 조금 느낄 수 있는가? 이 작은 프로그래밍으로 그 구분이 명확하게 되지 않을 테지만 그 조그만 차이를 느끼는 것만으로도 지금은 충분하다.


### 1.2 과거에서 미래로

그렇다면 왜 세계의 주류 프로그래밍 패러다임은 선언적 프로그래밍이 아니라 명령형 프로그래밍이 되었을까? 오래부터 두 패러다임은 함께 존재했지만 7~80년대가 지나가면서 주류가 된 것이 명령형 프로그래밍이었다. 그 이유는 아마도 기계어 였을 것이다. ADD, MOV, INTO, SUM등의 명령어가 컴퓨터에게나 사람에게나 더 직관적이었다. 1:1로 옮기기만 하면 되었을테니까. 또한 그 시대의 컴퓨터 성능이 그렇게 좋지 못했다는 것도 한 몫 할 것이라고 추측된다. 컴퓨터 성능이 나쁘다는 것은 컴파일러의 성능이 좋지 못하단 이야기가 될 것이고, 컴파일러의 성능이 나쁘다는 이야기는 곧 명령형 프로그래밍이 더 좋은 개발 환경이었다는 이야기가 될 것이다.

그렇지만 기뻐하시라. 더이상 명령형 프로그래밍만 해야 하는 시대는 지났다. 세계에 많은 프로그래머들이 선언형 프로그래밍에 매력을 느껴 앞다투어 이 흐름에 참여하고 있다. 또한 많은 언어들이 선언형 프로그래밍을 지원하며, 컴파일러의 성능 또한 이를 지원하는데 부족함이 없다.

물론 명령형 프로그래밍의 선두, 난공불락의 자바를 넘어서기엔 아직도 갈길이 한참 멀었지만 JDK8에 주요 기능인 Stream API가 들어오면서 익명 함수 사용이 가능해졌다. 아직은 부족함이 많지만 이제 자바로도 선언형 프로그래밍을 하는 것이 가능해졌다는 이야기다. 필자들은 앞으로 자바 진영에서 더욱 선언형 프로그래밍을 받아들이리라고 생각한다.


### 1.3  함수형 프로그래밍(Functional Programming)

명령형 프로그래밍의 대표는 단연코 객체지향 프로그래밍이다. 그렇다면 선언형 프로그래밍의 대표는 무엇일까? 짐작하고 있겠지만 이는 함수형 프로그래밍이다. 자 이제 드디어 함수형 프로그래밍에 대해서 이야기 해보자.

함수형 프로그래밍에 대해서 위키피디아를 검색해보면 아래와 같이 설명하고 있다.

> 함수형 프로그래밍은 자료 처리를 수학적 함수의 계산으로 취급하고 상태와 가변 데이터를 멀리하는 프로그래밍 패러다임의 하나이다. 명령형 프로그래밍에서는 상태를 바꾸는 것을 강조하는 것과는 달리, 함수형 프로그래밍은 함수의 응용을 강조한다. 함수형 프로그래밍은 1930년대에 계산가능성, 결정문제, 함수정의, 함수응용과 재귀를 연구하기 위해 개발된 형식체계인 람다 대수에 근간을 두고 있다. 다수의 함수형 프로그래밍 언어들은 람다 연산을 발전시킨 것으로 볼 수 있다.

수학적 함수와 명령형 프로그래밍에서 사용되는 함수는 차이가 있는데, 명령형의 함수는 프로그램의 상태의 값을 바꿀 수 있는 부작용이 생길 수 있다. 이 때문에 명령형 함수는 참조 투명성이 없고, 같은 코드라도 실행되는 프로그램의 상태에 따라 다른 결과값을 낼 수 있다. 반대로 함수형 코드에서는 함수의 출력값은 그 함수에 입력된 인수에만 의존하므로 인수 x에 같은 값을 넣고 함수 f를 호출하면 항상 f(x)라는 결과가 나온다. 부작용을 제거하면 프로그램의 동작을 이해하고 예측하기가 훨씬 쉽게 된다. 이것이 함수형 프로그래밍으로 개발하려는 핵심 동기중 하나이다.
위의 글에서 핵심 키워드를 뽑아보면 `수학적 함수`, `불변 데이터(;가변 데이터를 멀리함)`, `재귀`, `람다`, `부작용`을 찾아볼 수 있다. 자 이 네 가지 키워드를 꼭 마음속에 기억해두자. 함수형 프로그래밍을 공부하면서 꼭 기억해야 하는 키워드 들이다.


### 1.4. 정리

이번 장을 통해서 프로그래밍 패러다임에 대해서 살펴봤다. 명령형 프로그래밍은 "프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 프로그래밍" 이며, 객체지향 프로그래밍이 있고, 선언적 프로그래밍은 "문제를 해결하는 방법을 제시하는 프로그래밍"이며, 함수형 프로그래밍이 있다는 것을 알아보았다. 함수형 프로그래밍의 4가지 핵심 키워드 `수학적 함수`, `불변 데이터`, `람다`, `부작용` 이라는 것을 살펴보았다. 자 함수형 프로그래밍에 대해서 어느정도 알아 보았으니 이제 다음으로 넘어갈 준비가 끝났다.

## 2장 참조 투명성, 순수성, 그리고 치환 모형

함수형 프로그래밍에 대해서 더 깊이 있게 탐색하고자 할 때 꼭 필요한 수학적 지식과 용어들이 있다. 이번 장에서는 이러한 것들에 대해 차근차근 설명해 보려고 한다. 또한 지루함을 달래기 위해 간단한 예제들도 함께 할 것이다.

### 2.1 함수

우리가 보통 프로그램을 배우면서 처음 배우는 함수는 아래와 같다.

코드2.1 프로그래밍에서 사용하는 함수

````java
public static void main(String[] args){
    System.out.println( "Hello world");
}
````

우리가 앞으로 마음속에 품어야 할 것은 이런 함수가 아니라 바로 수학(mathematics)에서의 함수이다. 수학적 의미의 함수는 "첫 번째 집합의 임의의 한 원소를 두 번째 집합의 오직 한 원소에 대응시키는 대응 관계이다."이다.


그림2.1 함수 기호, X는 정의역 Y는 공역, f(x)의 함수를 사상하였을 때 나오는 결과의 집합을 치역(; D, C)이라 한다.

![image](https://cloud.githubusercontent.com/assets/4495200/26612150/cc981708-45ed-11e7-9395-f3515eb054ab.png)


두 개의 차이는 무엇일까? 바로 "부수 효과(side effect)"의 존재 여부이다. 함수형 프로그래밍(functional programming)에서는 부수효과가 없는 수학적 용어의 함수로 프로그래밍을 하는 것이다. 이러한 함수들을 가리켜 "순수함수(pure function)"라 한다.

순수 함수들로 프로그램을 작성하면 얻을 수 있는 장점은 모듈성(modularity)가 증가하는 것이다. 모듈성 덕분에 순수 함수는 테스트, 재사용, 병렬화, 분석이 더 쉽다. 때문에 순수 함수로 프로그래밍을 작성하게 되면 버그가 생길 여지도 훨씬 적어진다.

### 2.2 부수효과

앞선 절에서 함수를 설명하면서 순수 함수라는 것이 "부수효과"가 없는 것이라고 설명했다. 그렇다면 자주 접하던 그 부수효과란 과연 무엇일까? 우리가 공부했던 함수형 프로그래밍 책에서는 아래와 같이 7개의 예를 들어주고 있다.

* 변수를 수정한다.
* 데이터 구조를 변경한다.
* 객체의 필드를 설정한다.
* 예외(exception)를 던지거나 오류를 내면서 실행을 중단한다.
* 콘솔에 출력하거나 사용자의 입력을 읽어들인다.
* 파일에 기록하거나 파일에서 읽어들인다.
* 화면에 그린다.

변수를 수정하거나 예외를 던지는 것, 파일에 기록하거나 읽어드리는 것이 없이 프로그램을 작성한다는 것에 대해서 상상해본적이 있는가? 아마도 없거나 절대 불가능하다고 생각할지도 모르겠다. 다행하게도 부수효과를 제거하여 프로그래밍을 작성하는 것이 가능하며 이렇게 작업하는 방법을 배우고나면 앞으로 훨씬 행복해질 수 있다.

### 2.3 참조 투명성

이제 참조 투명성(referential transparency)에 대해서 살펴보자. 우선 간단하게 더하기 함수에 대해서 살펴보자.

코드 2.2 더하기 함수

````scala
def sum(a: Int, B: Int): Int = {
  a + b
}
````

더하기 함수는 정수 값 두개를 받아서 값을 더한 값을 반환한다. 주어진 임의의 두 정수에 대해 이 함수는 항상 같은 값을 돌려준다.

예를 들어 2와 3 숫자를 위의 sum 함수를 사용해서 결과를 낸다고 생각해보자. 그렇다면 우리가 수학에서 생각했던 2 + 3 = 5라는 공식을 머리속에 그려낼 수 있고 이는 입력 값 2, 3에 대해 결과 값 5가 나오는 동작만 수행할 뿐 다른 일을 하지 않는다.

순수 함수의 이러한 개념을 바로 **참조 투명성**이라 한다. 아래는 우리가 공부한 책에서 밝히고 있는 참조 투명성과 순수성의 정의이다.

> 모든 프로그램 p에 대해 표현식 e의 모든 출현을 e의 평가로 치환해도 p의 의미에 아무 영향이 미치지 않는다면, 그 표현식 e는 참조에 투명하다. 만일 표현식 f(x)가 참조에 투명한 모든 x에 대해 참조에 투명하면, 함수 f는 순수하다

### 2.4 치환 모델

어떤 함수가 참조 투명하다고 표현할 수 있는 것은 위의 절에서 언급한 것처럼 모든 입력에 대해서 그 결과 값이 항상 동일할 때를 말한다. 프로그래밍에서 함수가 이러한 사항을 충실히 이행하면 **치환 모델(substitution model)**이라고 부르는 추론 모형이 가능해진다. 참조 투명성은 프로그램에 대한 등식적 추론을 가능하게 하는데 이를 활용하면 프로그램에서 함수를 적극적으로 재활용할 수 있는 길이 열리는 것이다.

### 2.5 정리

이번 장에서는 함수형 프로그래밍에서 이야기하는 몇 가지 용어에 대해서 살펴보았다. 여기서 몇 가지 언급하지 않은 것이 있는데 그것은 다음 장에서 필요할 때 언급할 것이다. 이번 장에서 꼭 기억할 것은 바로 "부수 효과"의 정의이다. 부수효과는 변수 수정, 데이터 구조 변경, 예외를 던지는 것 등이다. 그리고 이런 부수효과를 제거하면 함수형 프로그래밍에서 꼭 언급되는 참조투명성과 만나게 된다. 다음은 모노이드에 대해서 살펴볼 차례이다.


## 3장 모노이드(Monoid)

### 3.1 Monoid란 무엇인가?

모노이드(Monoid)에 대해 이야기하기 전에, 집합(Set)과 마그마(Magma), 반군(Semigroup)에 대해 먼저 이야기하고 넘어가겠다.

Set과 Magma, Semigroup, 그리고 Monoid는 모두 추상대수학에서 나온 개념이다. 그렇다고 너무 어렵게 생각할 필요는 없다. 우리가 그런 용어를 모르고 있을 뿐이지, 각각의 용어가 설명하는 개념에 대해서는 익숙히 알고 있는 내용이기 때문이다.

먼저 Set은 우리가 흔히 말하는 집합을 말한다. 여기에 이항 연산자가 추가되면 Magma가 된다. 예를 들어, '정수'는 집합이다. 여기에 '덧셈'이라는 이항 연산을 묶은 것을 Magma라고 한다. Magma가 결합 법칙을 만족하면 Semigroup이 된다. 결합 법칙은 연산의 결과가 연산의 순서에 영향을 받거나 받지 않는 것을 말한다. 정수의 덧셈을 보면, 5+2+4 의 연산에 대해 (5+2)+4 와 5+(2+4)의 결과는 항상 같다. 즉, 정수의 덧셈은 결합 법칙을 만족한다. 반면에 정수의 뺄셈은 결합 법칙을 만족하지 않는다. (5-2)-4는 5-(2-4)의 결과는 같지 않다.

그렇다면, 모노이드는 무엇일까? Wikipedia에서는 모노이드에 대해 다음과 같이 설명하고 있다.

> 추상대수학에서 모노이드는 항등원을 갖는, 결합 법칙을 따르는 이항 연산을 갖춘 대수 구조이다. - wikipedia

Set, Magma, Semigroup과 연관시켜보면, Semigroup이 항등원을 가질 때 그걸 모노이드라고 할 수 있다. 정확히는, 결합 법칙과 항등 법칙을 합쳐서 모노이드 법칙이라고 부르며 모노이드 법칙을 만족하는 대수적 구조를 모노이드라고 한다.

모노이드를 Scala trait으로 표현하면 다음과 같다. (개념 설명을 위한 예시로서 실제로 scalaz 등에서 구현된 내용과는 다를 수 있다.)

````scala
trait Monoid[A] {
  def op(a1: A, a2: A): A
  def zero: A
}
````

trait Monoid의 구현은 op와 zero에 대해 다음의 성질을 만족해야 한다.

op(op(x, y), z)는 op(x, op(y, z))와 동등하다.
op(x, zero)는 x와 동등하며, op(zero, x) 역시 x와 동등하다.
결합 법칙과 항등 법칙을 만족하는 예로 무엇이 있을까? 우리는 정수의 덧셈이 결합 법칙을 만족한다는 것과, 덧셈의 항등원이 0이라는 것을 알고 있다. 정수의 곱셉은 어떤가. 정수의 곱셈 역시 결합 법칙을 만족하며 그 항등원은 1이 된다. 다시 말해, 정수의 덧셈과 정수의 곱셈 연산은 각각 하나의 모노이드라고 할 수 있다. 이를 코드로 표현해보면 다음과 같다.

##### 정수의 덧셈

````scala
val intAdditionMonoid = new Monoid[Int] {
  def op(a1: Int, a2: Int): Int = a1 + a2
  def zero = 0
}
````

##### 정수의 곱셈

````scala
val intMultiplicationMonoid = new Monoid[Int] {
  def op(a1: Int, a2: Int): Int = a1 * a2
  def zero = 1
}
````

이 외에도, 문자열이나 목록의 결합 연산 역시 모노이드로 표현할 수 있다.

##### String Concatenation

````scala
val stringConcatMonoid = new Monoid[String] {
  def op(a1: String, a2: String): String = a1 + a2
  def zero = ""
}
````

##### List Concatenation

````scala
val listConcatMonoid[A] = new Monoid[List[A]] {
  def op(a1: List[A], a2: List[A]): List[A] = a1 ++ a2
  def zero = Nil // scala에서 Nil은 empty list와 같다
}
````

##### Option

````scala
val optionMonoid[A] = new Monoid[Option[A]] {
  def op(a1: Option[A], a2: Option[A]): Option[A] = a1 orElse a2
  val zero = None
}
````

### 3.2 Monoid의 이점

모노이드가 무엇인지는 알겠다. 그런데 왜 모노이드에 대해 알아야 하는 걸까? 모노이드는 Foldable을 지원하는 자료 구조에 대해 접기 연산을 할 수 있다는 것과, 그러한 연산을 병렬로 처리할 수 있다는 말과 같기 때문이다.

Foldable은 목록을 하나로 축약하는 것을 말한다. 정수 목록 List(1, 2, 3, 4)를 생각해보자. 4개의 항목이 있는 이 목록을 하나로 축약하려면 각각의 항목이 하나로 합쳐질 때의 연산이 필요하다. 각각의 항목을 모두 더하면서 하나로 만든다고 가정해보면, 결국 List(1, 2, 3, 4)를 접는 것은 1과 2를 더하고, 그 결과에 3을 더하고, 다시 그 결과에 4를 더한다는 것이다. 즉, ((1+2)+3)+4이다.

앞에서 정수의 덧셈이 모노이드이며 intAdditionMonoid로 표현할 수 있다는 것을 알고 있다. 정수 x와 정수 y의 덧셈 연산은 op(x, y)로 표현할 수 있는 것이다. 따라서 List(1, 2, 3, 4)에 대한 접기 연산은 접는 방향에 따라 다음과 같이 표현할 수 있다.

````scala
op(op(op(1, 2), 3), 4) // foldLeft
op(1, op(2, op(3, 4))) // foldRight
````

모노이드는 결합 법칙을 만족하기 때문에 intAdditionMonoid에서 위의 두 연산은 동일한 결과를 반환한다. 접는 과정에서의 연산을 덧셈이 아니라 뺄셈으로 변경한다면 접는 방향에 따라 foldLeft와 foldRight의 결과가 달라질 것이다. 그렇다면 모노이드에 대해 다음과 같은 연산은 어떨까?

````scala
op(op(1, 2), op(3, 4))
````

이 역시 결과는 같다. 하지만 앞서의 두 연산과 비교해보면 작지만 큰 차이가 있다. 1부터 4까지의 덧셈 연산을 위와 같이 표현할 수 있다는 것은, op(1, 2) 연산과 op(3, 4) 연산을 병렬로 수행할 수 있다는 의미이다.

op(op(op(1, 2), 3), 4)의 경우 op(1, 2)가 먼저 수행되어야만 그 결과인 3을 가지고 op(3, 3) 연산을 수행할 수 있다. 그에 비해 op(op(1, 2), op(3, 4))의 표현은 op(1, 2)와 op(3, 4)의 연산이 동시에 수행되어도 무방하리라는 것을 짐작할 수 있다.

즉, 모노이드는 결합 법칙을 만족하기 때문에 연산을 병렬적으로 수행할 수 있는 유연성을 가지게 된다.

### 3.3 정리

이번 장에서 처음으로 대수적 특징을 활용하는 사례를 살펴보았다. 모노이드 특질은 명칭이 갖는 의미보다 더 중요한 것이 있다. 바로 모노이드를 만족하면 자유롭게 동시성 프로그래밍의 여러 문제에서 해방 된다는 것이다. 멋진 일이지 않은가? 아무런 신경을 쓰지 않고도 멀티 스레드 프로그래밍을 할 수 있다니. 이제 더 멋진 녀석들을 만나러 가자.


## 4장 펑터

### 4.1 Functor란 무엇인가?

Functor는 보통 펑터라고 부르며, 프로그래머 세계에서는 함수자로 불린다. 함수자에 대한 위키피디아의 사전적 설명은 아래와 같다.

> 범주론에서 함자(函子, 영어: functor 펑크터[*])는 두 범주 사이의 함수에 해당하는 구조로, 대상을 대상으로, 사상을 사상으로 대응시킨다. 함자는 작은 범주의 범주의 사상으로 볼 수 있다.
좀 더 간결하게 다듬어서 이야기 해보면 "자료 타입에서 map 구현이 가능하고, 특정 법칙을 만족한다면" 이것을 Functor라고 할 수 있다.


함수형 프로그래밍 언어들로 개발 하다가 보면 여러 map함수를 만날 수 있다. map은 사상한다는 의미로 보통 List에서는 아래와 같이 사용할 수 있다.


코드5.1 List의 map 함수

````bash
scala> val list = (1 to 10).toList
list: List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

scala> list.map(x => x * 3)
res0: List[Int] = List(3, 6, 9, 12, 15, 18, 21, 24, 27, 30)
````

이렇게 자료구조에 사용할 수도 있고, Option이나 Future에서도 map을 사용할 수 있다.

코드5.2 Option의 map 함수

````bash
scala> val option = Option(5)
option: Option[Int] = Some(5)

scala> option.map(x => x * 5)
res4: Option[Int] = Some(25)
````

코드5.3 Future의 map 함수

````bash
scala> import scala.concurrent._
import scala.concurrent._

scala> import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.ExecutionContext.Implicits.global

scala> future.map(x => x * 5)
res5: scala.concurrent.Future[Int] = scala.concurrent.impl.Promise$DefaultPromise@37468787

scala> res5.map(x => println(x))
25
res6: scala.concurrent.Future[Unit] = scala.concurrent.impl.Promise$DefaultPromise@330c1f61
````

위의 예제 소스들을 보면 map은 내부의 요소들만 수정하며, 타입을 변경하지는 않는다. 이를 구조의 보존(Structure-Preserving) 법칙이라 하며, 함수자를 정의하는 중요한 법칙이다.

따라서 항등 함수를 적용한다면 자기 자신이며 아래와 같은 수식이 만족된다.

````scala
x.map( a => a ) == x
````

### 4.2 Functor의 이점

Functor가 가지는 이점은 Functor의 추상을 응용하여 유용한 함수들을 발견할 수 있다. 다시 말해 map함수만으로도 추가적인 유용한 연산들을 정의할 수 있다는 것이다.

예를 들어 List안에 Tuple이 있다고 할 때, 우리는 map 연산을 통해서 이를 2개의 List의 Tuple로 분리할 수가 있다. 아래 코드를 보자.

````bash
scala> val list = List((1,2),(3,4),(4,5))
list: List[(Int, Int)] = List((1,2), (3,4), (4,5))

scala> ( list.map(e => e._1), list.map(e => e._2) )
res0: (List[Int], List[Int]) = (List(1, 3, 4),List(2, 4, 5))
````

이렇게 map함수를 이용해서 첫번째 요소의 리스트와, 두번째 요소의 리스트를 간단하게 분리할 수 있다.

이 함수가 여러분들이 알고 있는 unzip 함수 이다.

````bash
scala> list.unzip
res1: (List[Int], List[Int]) = (List(1, 3, 4),List(2, 4, 5))
````

###4.3 정리

이번 장에서 살펴본 Functor는 모노이드 보다는 훨씬 더 이해하기 쉽고 간단해보인다. 하지만 Functor를 활용하여 유용한 여러 함수를 발견할 수 있다는 사실이 중요하다. Functor에 대해서 더욱 깊게 고찰하면 결국 모나드를 만나게 된다. Functor자체 만으로도 강력하지만 펑터는 사실 빙산에 일각에 불과하다. 그 뒤에 모나드, 어플리커티브, 프리모나드 까지 엄청난 녀석들이 줄줄이 사탕으로 달려있다. 다음 장으로 넘어가서 모나드에 대해서 살펴보자.

## 5장 모나드

### 5.1 Monad란 무엇인가?

Monad도 Functor와 마찬가지로 몇가지의 구현과 법칙을 통해 정의해 볼 수 있다. 하지만 Functor 보다 훨씬 더 강력한 이점들을 얻을 수 있다. 일반적으로 자료 타입에서 unit, flatMap 구현이 가능하고, 몇가지 법칙(Law)을 만족한다면 우리는 이것을 Monad라 할 수 있다. Monad란 “flatMap을 구현하는 자료형식”이라는 관점에서 볼때, flatMap의 추상화라고 할 수 있다. Monad 역시 여러 함수형 라이브러리드에서 추출할 수 있는 여러 추상들 중 하나이다.

#### 5.1.1  flatMap 추상화

Functor에서와 마찬가지로, 우리가 흔히 사용하는 Option 과 List를 통해 flatMap을 구현할 수 있다.

````scala
def flatMap[A, B](oa: Option[A])(fb: A => Option[B]): Option[B] = oa flatMap fb
def flatMap[A, B](la: List[A])(fb: A => List[B]): List[B] = la flatMap fb
````

컨테이너 타입(Option, List)을 M으로 일반화 하면, 다음과 같다.

````scala
def flatMap[A, B](ma: M[A])(fb: A => M[B]): M[B]
````

즉, flatMap은 컨테이너 타입 M의 내부 값을 꺼내서 fa함수를 적용해서 반환값을 돌려준다.

얼핏 보면 map과 동일해 보이지만, flatMap은 두번째 파라미터가 값을 받아서 컨테이너 타입을 반환하는 함수이다.M[M[A]]이 반환 될 것으로 예상되지만, 실제로 평평(flat)하게 처리되어 M[A]으로 반환된다는 차이점이 있다.

````scala
def oneToSizeList(i: Int) = (1 to i toList) map (_.toString) 
defined function oneToSizeList

List(1,2,3).flatMap(oneToSizeList) 
res1: List[String] = List("1", "1", "2", "1", "2", "3")

// List[Int] => List[String] (O)
// List[Int] => List[List[String] (X) 
// result: List[List[Int]] = List(List("1"), List("1", "2"), List("1, "2", "3")) 
````

#### 5.1.2 unit

Monad에서는 값을 받아서 해당 컨테이너 타입에 그 값을 담아서 돌려 주는 unit 함수가 필요하다. 스칼라에서는 일반적으로 생성자나 case class 의 apply 메소드로 구현한다.

````scala
def apply[A](x: A): Option[A] // Option의 apply
def apply[A](xs: A*): List[A] // List의 apply
````

컨테이너 타입(Option, List)을 M로 일반화 하고, 이름을 unit으로 변경하면, 다음과 같다.

````scala
def unit[A](a: => A): M[A]
````

unit은 인자로 받은 값을 감싼 컨테이너 타입으로 반환한다.



#### 5.1.3  법칙(Law)

* 결합법칙

Monad에서 결합법칙이란, 연속된 두개의 flatMap 연산에서  첫번째 연산을 먼저 평가하고, 그 결과를 두번째 연산에 적용한 것과 두번째 연산을 평가하는 함수를 첫번째 연산에 적용한 결과는 동일해야 한다.

````scala
flatMap(flatMap(m)(f))(g) == flatMap(m)(x => flatMap(f(x))(g))
````

flatMap을 이항연산으로 표현할 경우 다음과 같이 표시 할 수 있고,  

````scala
(m flatMap f) flatMap g = m flatMap (x => f(x) flatMap g))
````

이것은 덧셈의 결합법칙과 동일하다.

````scala
(a + b) + c = a + (b + c)
````

*  항등법칙

첫번째 파라미터에 unit 적용(왼쪽 항등)

````scala
flatMap(unit(x))(f) == f(x) 
````

두번째 파라미터에 unit 적용(오른쪽 항등)

````scala
flatMap(m)(unit) == m
````

첫번째 파라미터에 컨테이너 타입 m을 적용하고,  두번째 파라미터에 unit을 적용했을 경우, m과 동일해야 한다. 

### 5.2. Monad의 이점

#### 5.2.1 Monad는 Functor의 확장

unit과 flatMap을 이용해 다음과 같이 Functor의 map을 구현할 수 있다.

````scala
def map[A, B] (ma: F[A])(f: A => B): F[B] = flatMap(ma)(a => unit(f(a)))
````

Moand는 Functor의 map 구현을 제공할 수 있으므로 Functor를 확장할 수 있다. 그러므로 모든 Monad는 Functor라고 할 수 있지만, 모든 Functor가 Monad인 것은 아니다.

#### 5.2.2 unit과 flatMap을 용해 이미 구현된 유용한 함수들

Monad가 가지는 이점 중 하나는 Functor와 마찬가지로, unit과 flatMap의 추상을 응용하여 유용한 함수들을 발견할 수 있다. 다시 말해 unit과 flatMap 함수만으로도 추가적인 유용한 연산들을 정의할 수 있다는 것이다.

````scala
def map2[A,B,C](fa: F[A], fb: F[B])(f: (A,B) => C): F[C] =
  flatMap(fa)(a => map(fb)(b => f(a,b)))

def sequence[A](lma: List[F[A]]): F[List[A]] =
  lma.foldRight(unit(List[A]()))( (fa, fb) => map2(fa, fb)( (a, b) => a :: b))

def traverse[A, B](la: List[A])(f: A => F[B]): F[List[B]] =
  la.foldRight(unit(List[B]()))( (a, fb) => map2(f(a), fb)( (a, b) => a :: b))

def replicateM[A](n: Int, ma: F[A]): F[List[A]] = sequence(List.fill(n)(ma))
````


일단 한번만 정의해 두면 코드의 중복을 크게 줄일 수 있는 유용한 연산을 많이 만들어 낼 수 있다. 더 다양한 함수들은 스칼라 함수형 프로그래밍을 위한 라이브러리인 cats scala library(Monad trait)에서 확인 할 수 있다.

#### 5.2.3 for comprehension 

* map과 flatMap을 이용한 구구단

````scala
(2 to 9).flatMap( i => (1 to 9).map( j => s"$i*$j=${i*j}"))
````

* for comprehension을 이용한 구구단

````scala
for {
  i <- 2 to 9
  j <- 1 to 9
} yield s"$i*$j=${i*j}"
````

for comprehension는 sugar syntax로써 복잡한 코드를 개발자 쉽게 사용할 수 있도록, 그리고 가독성을 높여 주기 위한 문법이다. 여기서는 flatMap과 map의 코드를 변환하는 예제를 보여줬지만, 실제로는 좀 더 다양한 방법으로 for comprehension 사용할 수 있다.

### 5.3 정리

이번 장을 통해서 함수형 프로그래밍에서 가장 무시무시한 존재 모나드에 대해서 살펴보았다. 모나드 자체는 너무 추상적인데다가 감에 의존하여 판단하는 경우가 많아서 "이게 모나드 인가" 하는 의심만 드는 경우가 대부분이다. 그리고 너무나도 다행인 것은 모나드를 모른다고 해도 살아가는데 아무런 어려움이 없다는 사실이다. 이 사실에 안도하면서 이 글을 마친다.


## 스터디를 하면서 느낀점 및 맺음말

### 조동호 

함수형 프로그래밍에 큰 관심이 있었던 것은 아니다. Google의 Guava Library를 사용하면서 코드의 가독성이라는 주제에 대해 생각하기 시작하게 되었고, Java 외의 다른 언어들은 어떻게들 쓰고 있나 보기 시작하면서 자연스럽게 Scala와 함수형 프로그래밍으로 관심이 옮겨가게 되었던 것 같다. Functional하게 작성된 코드는 그렇지 않은 코드에 비해 확실히 읽기가 수월하다. 지금 생각해보면 상태 변경이 없는 코드가 더 읽기 쉬운게 당연한 거지만 그때는 그런 생각을 못했었다. 어떤 코드는 잘 읽히는데 왜 어떤 코드는 볼 때마다 헷갈리는 걸까. 그런 작은 의문에서 시작했던 것이 함수형 프로그래밍에 대한 공부에까지 이르렀다. 함수형 프로그래밍에 대해 공부하는 것은 즐거운 일이었다. 크게 의식하지 않고 사용했던 함수들을 한번 더 들여보다 그들이 지닌 함의를 깨달아 가는 과정은 그 나름의 매력이 있는 일이었다. 큰 깨달음이나 완벽한 이해를 얻지 못해도 좋다. 당장은 어렵더라도 그러한 관심과 노력이 이어지는한, 함수형 프로그래밍 언어를 점점 더 함수적으로 사용할 수 있게 되리라 믿는다.

### 김진억 

함수형 프로그래밍이 장점이 많음에도 불구하고 많은 개발자들이 어려워 하고 꺼려하는 이유는 수학적 이론을 기반으로 한 추상적인 개념들 때문이라 생각된다. 카테고리 이론, 펑터, 모노이드, 모나드 등등 이 모든 개념들이 생소하기도 하지만, 검색 했을 때 그 결과 내용이 더 이해하기 어려워 많은 사람들을 좌절에 빠트리는 것 같다. 수학 이론을 기반으로 했기 때문에 수학적 개념들을 이해하고 함수형 프로그래밍에 접근한다면 더 도움이 되겠지만, 굳이 이를 이해하지 않아도 접근하는데 크게 문제가 되지 않으리라 생각된다. 함수형 프로그래밍에서는 함수의 추상화를 통해서 함수를 재사용 함으로써 효율적인 프로그래밍을 할 수 있다. 예전에 중,고등학교에서 수학을 배울때 공식을 배우고, 이 공식을 적용해 답을 얻거나 또 다른 결과를 유추할 수 있었던 것 처럼, 함수형 프로그래밍에서의 추상화(Monoid, Functor, Monad 등등)를 통해, 또 다든 결과를 얻거나 또 다른 함수들을 만들어 효율적인 프로그래밍을 할 수 있다. 추상적인 용어에 너무 집착해서 좌절을 맛보기 보다는 (라이프니츠의 모나드, 카테고리 이론을 따라갔다가 크게 낭패를 봤다는…), 단순하게 받아들이고, 코드, 함수의 공통점, 법칙을 기반으로 이것들로 인해 얻을 수 있는 이점들을 배우고 사용하면 자연스럽게 함수형 프로그래밍에 익숙해지지 않을까 생각된다. 

### 김경범 

처음 함수형 프로그래밍에 대해서 관심을 갖게 된 계기는 Play framework를 스칼라로 공부면서 시작되었다. 처음 개발자로 직장을 구하고 새로운 것에 대한 호기심으로 시작한 스터디였다. 아직도 그때 놀랐던 감정이 남아 있다. for 루프 말고 다른 방식으로 컬렉션을 다루는 방법이라니. 그때 사용했던 함수가 바로 map, flatMap, reduce 이다. 그렇게 스칼라를 공부하기 시작한 것도 벌써 3년이 지났다. 그리고 이제서야 함수형 프로그래밍에 대해서 공부하게 되었다. 그리고 위에 나열한 함수들이 모나드, 모노이드, 펑터 그리고 이 모든 것들은 총칭하는 범주론(category theory) 이라는 엄청난 이론에 근거한 것임을 깨닫게 되었다. 3년 동안 스칼라를 사용하면서 그저 컬렉션을 다루는 함수로만 생각했던 것이 새로운 정의로 넘어가는 순간에 깨달음은 굉장히 달콤했다. 물론 그 과정이 엄청난 에너지를 소모했지만 말이다.
함수형 프로그래밍을 공부하면서 느낀 점은 이론 만큼이나 어려운 설명들이 계속 되었지만 한장씩 넘어갈 때마다 지식이 쌓이는 느낌이 좋았던 것 같다. 이제 스터디가 끝나고 더 이상 이러한 이론을 떠올리며 하루하루를 보내지 않아도 된다는 것이 너무나 감사할 다름이다.
나중에 함수형 프로그래밍에 대해서 공부할 예정이고, 스칼라에 대해서 조금 알고 있다면 이 책을 강력하게 추천한다. 그리고 꼭 긴 기간을 가지고 오랜기간 되새김질을 통해 탐험하면 좋겠다는 조언도 하고 싶다.

5개월간에 긴 스터디임에도 불구하고 함께 해준 김진억님, 김지수님, 김준섭님, 남석현님, 고재도님, 이창언님, 조동호님, 정진태님, 김소연님, 양원석님께 감사드립니다. 이렇게 열정적이고 참여율이 높은 스터디는 3년 동안 처음이었습니다. :)
